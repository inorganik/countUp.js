// Generated by CoffeeScript 1.8.0
(function() {
  var countUp,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.countUp = countUp = (function() {
    countUp.VERSION = '2.0.0';


    /**
     * Count Up
     * 
     * @class
     * @param {number} target element selector or var of previously selected html element where counting occurs
     * @param {number} startVal The value you want to begin at
     * @param {number} endVal The value you want to arrive at
     * @param {number} [decimals=0] Tumber of decimal places
     * @param {number} [duration=2] Duration of animation in second
     * @param {object} [options] Optional object of options (see below)
     *
     */

    function countUp(target, startVal, endVal, decimals, duration, options) {
      this.count = __bind(this.count, this);
      this.polyFill();
      this.root = {
        target: target,
        startVal: startVal,
        endVal: endVal,
        decimals: decimals,
        duration: duration
      };
      this.options = __extends(options, {
        useEasing: true,
        useGrouping: true,
        separator: ',',
        decimal: '.',
        prefix: '',
        suffix: ''
      });
      if (this.options.separator === '') {
        this.options.useGrouping = false;
      }
      this.element = typeof target === 'string' ? document.querySelector(target) : target;
      this.startVal = +startVal;
      this.endVal = +endVal;
      this.countDown = startVal > endVal ? true : false;
      this.startTime = null;
      this.timestamp = null;
      this.remaining = null;
      this.rAF = null;
      this.frameVal = this.startVal;
      this.decimals = Math.max(0, decimals || 0);
      this.dec = Math.pow(10, this.decimals);
      this.duration = duration * 1000 || 2000;
      this.printValue(this.startVal);
    }


    /**
     * Make sure requestAnimationFrame and cancelAnimationFrame are defined
     * polyfill for browsers without native support
     * by Opera engineer Erik MÃ¶ller
     * 
     * @method polyFill
     * @return
     *
     */

    countUp.prototype.polyFill = function() {
      var lastTime, vendors, x;
      x = 0;
      lastTime = 0;
      vendors = ['webkit', 'moz', 'ms', 'o'];
      while (x < vendors.length && !window.requestAnimationFrame) {
        window.requestAnimationFrame = window["" + vendors[x] + "RequestAnimationFrame"];
        window.cancelAnimationFrame = window["" + vendors[x] + "CancelAnimationFrame"] || window["" + vendors[x] + "CancelRequestAnimationFrame"];
        x++;
      }
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function(callback, element) {
          var currTime, id, timeToCall;
          currTime = new Date().getTime();
          timeToCall = Math.max(0, 16 - (currTime - lastTime));
          id = window.setTimeout(function() {
            return callback(currTime + timeToCall);
          }, timeToCall);
          lastTime = currTime + timeToCall;
          return id;
        };
      }
      if (!window.cancelAnimationFrame) {
        return window.cancelAnimationFrame = function(id) {
          return clearTimeout(id);
        };
      }
    };


    /**
     * Print value to the target element
     * 
     * @method printValue
     * @param {number} value
     * @return
     *
     */

    countUp.prototype.printValue = function(value) {
      var result;
      result = !isNaN(value) ? this.formatNumber(value) : '--';
      if (this.element.tagName === 'INPUT') {
        return this.element.value = result;
      } else {
        return this.element.innerHTML = result;
      }
    };


    /**
     * 
     * @method easeOutExpo
     * @param {number} t
     * @param {number} b
     * @param {number} c
     * @param {number} d
     * @return {number}
     *
     */

    countUp.prototype.easeOutExpo = function(t, b, c, d) {
      return c * (-(Math.pow(2, -10 * t / d)) + 1) * 1024 / 1023 + b;
    };


    /**
     * 
     * @method count
     * @param {number} timestamp
     * @return {number}
     *
     */

    countUp.prototype.count = function(timestamp) {
      var progress;
      if (this.startTime === null) {
        this.startTime = timestamp;
      }
      this.timestamp = timestamp;
      progress = timestamp - this.startTime;
      this.remaining = this.duration - progress;
      if (this.options.useEasing) {
        if (this.countDown) {
          this.frameVal = this.startVal - this.easeOutExpo(progress, 0, this.startVal - this.endVal, this.duration);
        } else {
          this.frameVal = this.easeOutExpo(progress, this.startVal, this.endVal - this.startVal, this.duration);
        }
      } else {
        if (this.countDown) {
          this.frameVal = this.startVal - (this.startVal - this.endVal) * (progress / this.duration);
        } else {
          this.frameVal = this.startVal + (this.endVal - this.startVal) * (progress / this.duration);
        }
      }
      if (this.countDown) {
        this.frameVal = this.frameVal < this.endVal ? this.endVal : this.frameVal;
      } else {
        this.frameVal = this.frameVal > this.endVal ? this.endVal : this.frameVal;
      }
      this.frameVal = Math.round(this.frameVal * this.dec) / this.dec;
      this.printValue(this.frameVal);
      if (progress < this.duration) {
        return this.rAF = requestAnimationFrame(this.count);
      } else {
        if (this.callback != null) {
          return this.callback();
        }
      }
    };


    /**
     * 
     * @method start
     * @param {function} callback
     * @return {boolean}
     *
     */

    countUp.prototype.start = function(callback) {
      this.callback = callback;
      if (!isNaN(this.endVal) && !isNaN(this.startVal)) {
        this.rAF = requestAnimationFrame(this.count);
      } else {
        console.error('countUp error: startVal or endVal is not a number');
        this.printValue();
      }
      return false;
    };


    /**
     * 
     * @method stop
     * @return
     *
     */

    countUp.prototype.stop = function() {
      return cancelAnimationFrame(this.rAF);
    };


    /**
     * 
     * @method reset
     * @return
     *
     */

    countUp.prototype.reset = function() {
      this.startTime = null;
      this.startVal = this.root.startVal;
      cancelAnimationFrame(this.rAF);
      return this.printValue(this.startVal);
    };


    /**
     * 
     * @method resume
     * @return
     *
     */

    countUp.prototype.resume = function() {
      this.stop();
      this.startTime = null;
      this.duration = this.remaining;
      this.startVal = this.frameVal;
      return requestAnimationFrame(this.count);
    };


    /**
     * 
     * @method resume
     * @return {string} formatted number
     *
     */

    countUp.prototype.formatNumber = function(numberString) {
      var rgx, x, x1, x2;
      numberString = "" + (numberString.toFixed(this.decimals));
      x = numberString.split('.');
      x1 = x[0];
      x2 = x.length > 1 ? this.options.decimal + x[1] : '';
      rgx = /(\d+)(\d{3})/;
      if (this.options.useGrouping) {
        while (rgx.test(x1)) {
          x1 = x1.replace(rgx, "$1" + this.options.separator + "$2");
        }
      }
      return "" + this.options.prefix + x1 + x2 + this.options.suffix;
    };

    return countUp;

  })();

}).call(this);
